<!doctype html>
<html lang="en">
  <head>
    <title>Avail metamask snap</title>
  </head>
  <body>
    <img
      src="https://blog.coinfabrik.com/wp-content/uploads/2019/04/polkadot-substrate.png"
      height="60"
    />
    <h2>Avail metamask snap</h2>
    <details>
      <summary>Instructions</summary>
      <ul>
        <li>First, click "Connect avail plugin". Then, try out the other buttons!</li>
        <li>Please note that:</li>
        <ul>
          <li>The Snap <b>package.json</b> must be located in the server root directory</li>
          <li>
            The Snap bundle must be hosted at the location specified by
            <b>package.json:web3Wallet:bundle:url</b>
          </li>
        </ul>
      </ul>
    </details>
    <br />
    <div>
      <!-- Snap connect button -->
      <div style="margin-bottom: 10px">
        <button class="connect-snap">Connect avail snap</button>
        <button class="configure">Set configuration</button>
        <button class="create-asset">Create dot asset</button>
        <button class="remove-asset">Remove dot asset</button>
        <button class="test-sign">Test Sign Payload</button>
        <button class="debug-api">Debug API Modules</button>
      </div>

      <!-- Public Key -->
      <div style="display: inline">Public key:</div>
      <div class="publicKey" style="display: inline; font-weight: bold"></div>
      <!-- separator -->
      <div style="margin-top: 10px"></div>
      <!-- Address -->
      <div style="display: inline">Address:</div>
      <div class="address" style="display: inline; font-weight: bold"></div>
      <!-- separator -->
      <div style="margin-top: 10px"></div>
      <!-- Snap connection status -->
      <div style="display: inline">Snap connected:</div>
      <div class="connected-snap" style="display: inline"></div>
    </div>
    <br />
    <div>
      <!-- Seed export button -->
      <div style="margin-bottom: 10px">
        <button class="export-seed">Export seed</button>
      </div>
      <!-- Seed -->
      <div>
        <div style="display: inline">Seed:</div>
        <div class="seed" style="display: inline; font-weight: bold"></div>
      </div>
    </div>
    <br />
    <div style="background-color: floralwhite">
      <h3 style="margin-block-end: 0">Avail substrate calls</h3>
      <div style="margin-top: 10px">
        <button class="head-button">Get substrate chain head</button>
        <span style="margin-left: 10px">Substrate chain head hash:</span>
        <span class="head" style="font-weight: bold"></span>
      </div>
      <div style="margin-top: 10px">
        <button class="balance-button">Get balance</button>
        <span style="margin-left: 10px">Balance:</span>
        <span class="balance" style="font-weight: bold"></span>
      </div>
      <h4 style="margin-block-end: 0">Block search</h4>
      <div>
        <details>
          <summary>Supported formats of tag</summary>
          <ul>
            <li>block id as string or number: 1629433</li>
            <li>
              block hash as hex string:
              0xc9fb400866641ca80ef3e760d904fe15a8c9eda6ff1bd769b0628e26e82d5c75
            </li>
            <li>"latest" (returns latest block)</li>
          </ul>
        </details>
      </div>
      <div style="margin-top: 10px; display: flex">
        <div style="margin-right: 10px">
          <label for="block-tag">Block tag</label>
          <input class="block-tag" id="block-tag" type="text" value="1629433" />
        </div>
        <div style="margin-left: 10px">
          <button class="block-find">Find block</button>
        </div>
        <span style="color: darkred; margin-left: 10px"
          >block tag is pre-filled with real block value for easy testing</span
        >
      </div>
      <br />
      <pre class="block-data" style="background-color: ghostwhite"></pre>
      <h4>Availscan api</h4>
      <button class="transactions-button">Get transactions</button>
      <span>Number of transactions:</span>
      <span class="numOfTransactions" style="font-weight: bold"></span>
      <div class="transactions"></div>
    </div>
  </body>

  <script>
    const snapId = `local:${window.location.href}`.slice(0, -1);

    async function test() {
      index = await ethereum.requestIndex();
      pluginApi = await index.getPluginApi(origin);
      console.log(pluginApi);
      const s = await pluginApi.sign(100, 'test-address');
      console.log(s);
    }

    async function invokeSnap(request) {
      return ethereum.request({
        method: 'wallet_invokeSnap',
        params: {
          snapId,
          request
        }
      });
    }

    // spans for status
    const FALSE = "<span style='color: darkred'>FALSE</span>";
    const TRUE = "<span style='color: darkgreen'>TRUE</span>";

    // snap connection
    const snapConnectButton = document.querySelector('button.connect-snap');
    const publicKeyLabel = document.querySelector('div.publicKey');
    const snapConnectedLabel = document.querySelector('div.connected-snap');
    const addressLabel = document.querySelector('div.address');
    snapConnectButton.addEventListener('click', connectSnap);
    snapConnectButton.disabled = false; // until keypair is fetched
    snapConnectedLabel.innerHTML = FALSE;
    // configuration
    const configureButton = document.querySelector('button.configure');
    configureButton.addEventListener('click', loadConfiguration);
    // create asset
    const sendTransferButton = document.querySelector('button.create-asset');
    sendTransferButton.addEventListener('click', sendTransfer);
    const removeAssetButton = document.querySelector('button.remove-asset');
    removeAssetButton.addEventListener('click', removeAsset);
    // test sign button
    const testSignButton = document.querySelector('button.test-sign');
    testSignButton.addEventListener('click', testSignPayload);
    // debug api button
    const debugApiButton = document.querySelector('button.debug-api');
    debugApiButton.addEventListener('click', debugApiModules);
    // export seed
    const exportButton = document.querySelector('button.export-seed');
    const seedLabel = document.querySelector('div.seed');
    exportButton.addEventListener('click', exportSeed);

    // SUBSTRATE CALLS

    // chain head
    const availHeadButton = document.querySelector('button.head-button');
    const headLabel = document.querySelector('span.head');
    availHeadButton.addEventListener('click', getChainHead);
    // balance
    const availBalanceButton = document.querySelector('button.balance-button');
    const balanceLabel = document.querySelector('span.balance');
    availBalanceButton.addEventListener('click', getBalance);

    // transactions
    const transactionsButton = document.querySelector('button.transactions-button');
    const transactionDiv = document.querySelector('div.transactions');
    const numberOfTransactionsSpan = document.querySelector('span.numOfTransactions');
    transactionsButton.addEventListener('click', getAllTransactions);

    // blocks
    const blockTagInput = document.querySelector('input.block-tag');
    const blockFindButton = document.querySelector('button.block-find');
    const blockData = document.querySelector('pre.block-data');
    blockFindButton.addEventListener('click', findBlock);

    async function loadConfiguration() {
      try {
        const c = await invokeSnap({
          method: 'configure',
          params: {
            configuration: {
              networkName: 'turing',
              wsRpcUrl: 'https://turing-rpc.avail.so/ws',
              unit: {
                image: '',
                symbol: 'AVAIL'
              },
              addressPrefix: 42
            }
          }
        });
        console.log(c);
      } catch (err) {
        console.error('Keys not generated', err);
      }
    }

    async function removeAsset() {
      try {
        await invokeSnap({
          method: 'transfer'
        });
      } catch (e) {
        console.log('Keys not generated', e);
      }
    }

    async function sendTransfer() {
      try {
        console.log('clicked');
        await invokeSnap({
          method: 'generateTransactionPayload',
          params: {
            module: 'dataAvailability',
            method: 'submitData',
            args: ['Test data submission']
          }
        });
      } catch (e) {
        console.log('problem creating transfer', e);
      }
    }

    async function findBlock() {
      let block = null;
      try {
        block = await invokeSnap({
          method: 'getBlock',
          params: {
            blockTag: blockTagInput.value
          }
        });
      } catch (e) {
        console.error('Unable to fetch substrate chain head', e);
      }
      if (block !== null) {
        console.log(block);
        blockData.innerHTML = JSON.stringify(block.block, null, 2);
      }
    }

    fetchPublicKey()
      .then((fetched) => {
        if (fetched) {
          snapConnectedLabel.innerHTML = TRUE;
          // connectButton.disabled = false;
        } else {
          snapConnectedLabel.innerHTML = FALSE;
          // connectButton.disabled = false;
        }
      })
      .catch((err) => console.error(err));

    async function exportSeed() {
      try {
        const res = await invokeSnap({ method: 'exportSeed' });
        console.log('response', res);
        if (!res) return false;

        /* 1. Show the raw seed */
        seedLabel.textContent = res.keyPair.rawSeedHex;

        /* 2. Download the Polkadot‑JSON */
        const jsonString = JSON.stringify(res.keyPair.json, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `${res.keyPair.address}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        return true;
      } catch (error) {
        console.error('exportSeed failed', error);
        return false;
      }
    }

    // snap functions

    async function fetchPublicKey() {
      let response = null;
      try {
        response = await invokeSnap({
          method: 'getPublicKey'
        });
      } catch (e) {
        console.log('fetchPublicKey - Keys not generated', e);
        publicKeyLabel.innerHTML = 'Error on key generation';
      }
      if (response != null) {
        publicKeyLabel.innerHTML = response;
        return true;
      }
      return false;
    }

    async function fetchAddress() {
      let response = null;
      try {
        response = await invokeSnap({
          method: 'getAddress'
        });
      } catch (e) {
        console.log('Keys not generated', e);
      }
      if (response != null) {
        addressLabel.innerHTML = response;
        return true;
      }
      return false;
    }

    async function connectSnap() {
      console.log('Connecting snap', snapId);
      try {
        await ethereum.request({
          method: 'wallet_requestSnaps',
          params: {
            [snapId]: {}
          }
        });
      } catch (e) {
        console.error('Connect Snap error', e);
        return;
      }
      snapConnectedLabel.innerHTML = TRUE;
      publicKeyLabel.innerHTML = 'In progress...';
      addressLabel.innerHTML = 'In progress...';

      let txPayload = null;
      try {
        txPayload = await invokeSnap({
          method: 'generateTransactionPayload',
          params: {
            module: 'dataAvailability',
            method: 'submitData',
            args: ['Hello Avail from MetaMask Snap!']
          }
        });

        console.log('GENERATE PAYLOAD RESULT:');
        console.log(txPayload);

        if (!txPayload || !txPayload.payload) {
          console.error('Invalid txPayload structure:', txPayload);
          return;
        }
      } catch (e) {
        console.error('Unable to generate payload:', e);
        return;
      }

      let signature = null;
      try {
        console.log('Signing payload:', txPayload.payload);
        signature = await invokeSnap({
          method: 'signPayloadJSON',
          params: {
            payload: txPayload.payload
          }
        });

        console.log('SIGN RESULT:');
        console.log(signature);

        if (!signature || !signature.signature) {
          console.error('Invalid signature structure:', signature);
          return;
        }
      } catch (e) {
        console.error('Unable to sign payload:', e);
        return;
      }

      let tx = null;
      try {
        console.log('Sending transaction with params:', {
          signature: signature.signature,
          txPayload: txPayload,
          network: 1
        });

        tx = await invokeSnap({
          method: 'send',
          params: {
            signature: signature.signature,
            txPayload: txPayload,
            network: 1
          }
        });

        console.log('SEND RESULT:');
        console.log(tx);
      } catch (e) {
        console.error('Unable to send transaction:', e);
      }

      // Fetch and display public key and address
      await fetchPublicKey();
      await fetchAddress();
    }

    async function testSignPayload() {
      console.log('Testing signPayloadJSON with proper payload structure...');

      try {
        // First generate a proper transaction payload
        const txPayload = await invokeSnap({
          method: 'generateTransactionPayload',
          params: {
            module: 'dataAvailability',
            method: 'submitData',
            args: ['Test data from MetaMask Snap']
          }
        });

        console.log('Generated txPayload:', txPayload);

        if (!txPayload || !txPayload.payload) {
          console.error('Invalid txPayload structure');
          return;
        }

        // Now test signing with the proper payload
        const signature = await invokeSnap({
          method: 'signPayloadJSON',
          params: {
            payload: txPayload.payload
          }
        });

        console.log('Signature result:', signature);
        alert('Sign test successful! Check console for details.');
      } catch (e) {
        console.error('Test sign failed:', e);
        alert('Sign test failed: ' + e.message);
      }
    }

    async function debugApiModules() {
      console.log('Debugging API modules...');

      try {
        // First, let's check what's available after configuration
        await loadConfiguration();

        // Now let's try to inspect the API structure
        const result = await invokeSnap({
          method: 'getChainHead'
        });

        console.log('Chain head result:', result);

        // Try different module combinations
        const testModules = [
          { module: 'dataAvailability', method: 'submitData', args: ['Hello Avail'] },
          { module: 'system', method: 'remark', args: ['0x48656c6c6f20417661696c'] },
          { module: 'system', method: 'remarkWithEvent', args: ['0x48656c6c6f20417661696c'] },
          {
            module: 'balances',
            method: 'transferKeepAlive',
            args: ['5D7GadfhbbkSqCugapLwP1nj6xkTZTEG1UbG11ndzCwEPBJh', '1000000000000000000']
          },
          {
            module: 'balances',
            method: 'transfer',
            args: ['5D7GadfhbbkSqCugapLwP1nj6xkTZTEG1UbG11ndzCwEPBJh', '1000000000000000000']
          }
        ];

        for (const test of testModules) {
          try {
            console.log(`Testing ${test.module}.${test.method}...`);
            const txPayload = await invokeSnap({
              method: 'generateTransactionPayload',
              params: test
            });
            console.log(`✅ ${test.module}.${test.method} works!`, txPayload);
          } catch (e) {
            console.log(`❌ ${test.module}.${test.method} failed:`, e.message);
          }
        }
      } catch (e) {
        console.error('Debug failed:', e);
      }
    }

    // polkadot/substrate functions

    async function getChainHead() {
      let response = null;
      try {
        response = await invokeSnap({
          method: 'getChainHead'
        });
      } catch (e) {
        console.log('Unable to fetch substrate chain head', e);
      }
      if (response != null) {
        headLabel.innerHTML = response;
        return true;
      }
      return false;
    }

    async function getBalance() {
      let response = null;
      try {
        response = await invokeSnap({
          method: 'getBalance'
        });
      } catch (e) {
        console.log('Unable to fetch balance', e);
      }
      if (response != null) {
        balanceLabel.innerHTML = response;
        return true;
      }
      return false;
    }

    async function getAllTransactions() {
      let response = null;
      try {
        response = await invokeSnap({
          method: 'getAllTransactions',
          params: {
            address: 'Dc6ouAsLFYLF7kCfAbW6j6kVN1FvoKcyAuTr1NCKmU2c8mk'
          }
        });
      } catch (e) {
        console.log('Unable to fetch transactions', e);
      }
      if (response != null) {
        numberOfTransactionsSpan.innerHTML = response.length.toString();
        transactionDiv.innerHTML = response;
        return true;
      }
      return false;
    }
  </script>
</html>
